name: Deploy

on:
  push:
    branches: [develop, main]

concurrency:
  group: deploy-${{ github.ref }}
  cancel-in-progress: false

permissions:
  id-token: write
  contents: read

env:
  AWS_REGION: ap-northeast-1

jobs:
  # ============================================================================
  # Install: checkout + npm ci + prisma generate + cache保存
  # ============================================================================
  install:
    runs-on: ubuntu-latest
    steps:
      - uses: actions/checkout@v4
      - uses: actions/setup-node@v4
        with:
          node-version: 22
      - uses: actions/cache@v4
        id: deps-cache
        with:
          path: node_modules
          key: deps-${{ hashFiles('package-lock.json', 'prisma/schema.prisma') }}
      - if: steps.deps-cache.outputs.cache-hit != 'true'
        run: npm ci
      - if: steps.deps-cache.outputs.cache-hit != 'true'
        run: npx prisma generate
        env:
          DATABASE_URL: postgresql://dummy:dummy@localhost:5432/dummy

  # ============================================================================
  # Lint: biome lint + tsc 型チェック（testと並列）
  # ============================================================================
  lint:
    needs: install
    runs-on: ubuntu-latest
    steps:
      - uses: actions/checkout@v4
      - uses: actions/setup-node@v4
        with:
          node-version: 22
      - uses: actions/cache/restore@v4
        with:
          path: node_modules
          key: deps-${{ hashFiles('package-lock.json', 'prisma/schema.prisma') }}
          fail-on-cache-miss: true
      - run: npm run lint
      - run: npx tsc --noEmit

  # ============================================================================
  # Test: Postgres service + prisma db push + vitest（lintと並列）
  # ============================================================================
  test:
    needs: install
    runs-on: ubuntu-latest
    services:
      postgres:
        image: postgres:16
        env:
          POSTGRES_USER: test
          POSTGRES_PASSWORD: test
          POSTGRES_DB: test
        ports: ["5432:5432"]
        options: >-
          --health-cmd="pg_isready"
          --health-interval=10s
          --health-timeout=5s
          --health-retries=5
    env:
      DATABASE_URL: postgresql://test:test@localhost:5432/test?schema=public
    steps:
      - uses: actions/checkout@v4
      - uses: actions/setup-node@v4
        with:
          node-version: 22
      - uses: actions/cache/restore@v4
        with:
          path: node_modules
          key: deps-${{ hashFiles('package-lock.json', 'prisma/schema.prisma') }}
          fail-on-cache-miss: true
      - run: npx prisma db push
      - run: npm run test:run

  # ============================================================================
  # Build App: メインDockerイメージをビルド+ECRへpush（GHAキャッシュ）
  # ============================================================================
  build-app:
    needs: [lint, test]
    runs-on: ubuntu-latest
    if: github.ref == 'refs/heads/develop' || github.ref == 'refs/heads/main'
    env:
      ENVIRONMENT: ${{ github.ref == 'refs/heads/main' && 'production' || 'staging' }}
    steps:
      - uses: actions/checkout@v4

      - uses: aws-actions/configure-aws-credentials@v4
        with:
          role-to-assume: ${{ secrets.AWS_ROLE_ARN }}
          aws-region: ${{ env.AWS_REGION }}

      - uses: aws-actions/amazon-ecr-login@v2
        id: ecr

      - uses: docker/setup-buildx-action@v3

      - name: Build and push app image
        uses: docker/build-push-action@v6
        with:
          context: .
          push: true
          provenance: false
          tags: |
            ${{ steps.ecr.outputs.registry }}/${{ vars.ECR_REPOSITORY }}:${{ github.sha }}
            ${{ steps.ecr.outputs.registry }}/${{ vars.ECR_REPOSITORY }}:${{ env.ENVIRONMENT }}-latest
          cache-from: type=gha,scope=app
          cache-to: type=gha,mode=max,scope=app

  # ============================================================================
  # Build Lambda: LambdaイメージをECRへpush（build-appと並列）
  # ============================================================================
  build-lambda:
    needs: [lint, test]
    runs-on: ubuntu-latest
    if: (github.ref == 'refs/heads/develop' || github.ref == 'refs/heads/main') && vars.LAMBDA_ECR_REPOSITORY != ''
    steps:
      - uses: actions/checkout@v4

      - uses: aws-actions/configure-aws-credentials@v4
        with:
          role-to-assume: ${{ secrets.AWS_ROLE_ARN }}
          aws-region: ${{ env.AWS_REGION }}

      - uses: aws-actions/amazon-ecr-login@v2
        id: ecr

      - uses: docker/setup-buildx-action@v3

      - name: Build and push Lambda image
        uses: docker/build-push-action@v6
        with:
          context: .
          file: lambda/document-analysis/Dockerfile
          push: true
          provenance: false
          tags: |
            ${{ steps.ecr.outputs.registry }}/${{ vars.LAMBDA_ECR_REPOSITORY }}:${{ github.sha }}
            ${{ steps.ecr.outputs.registry }}/${{ vars.LAMBDA_ECR_REPOSITORY }}:latest
          cache-from: type=gha,scope=lambda
          cache-to: type=gha,mode=max,scope=lambda

  # ============================================================================
  # Update Lambda: 関数コード更新 + 環境変数同期
  # ============================================================================
  update-lambda:
    needs: [build-lambda, migrate-db]
    runs-on: ubuntu-latest
    if: (github.ref == 'refs/heads/develop' || github.ref == 'refs/heads/main') && vars.LAMBDA_FUNCTION_NAME != ''
    env:
      ENVIRONMENT: ${{ github.ref == 'refs/heads/main' && 'production' || 'staging' }}
    steps:
      - uses: aws-actions/configure-aws-credentials@v4
        with:
          role-to-assume: ${{ secrets.AWS_ROLE_ARN }}
          aws-region: ${{ env.AWS_REGION }}

      - uses: aws-actions/amazon-ecr-login@v2
        id: ecr

      - name: Update Lambda function
        env:
          ECR_REGISTRY: ${{ steps.ecr.outputs.registry }}
          LAMBDA_ECR_REPOSITORY: ${{ vars.LAMBDA_ECR_REPOSITORY }}
          LAMBDA_FUNCTION_NAME: ${{ vars.LAMBDA_FUNCTION_NAME }}
          IMAGE_TAG: ${{ github.sha }}
          SSM_PREFIX: /metalk/${{ env.ENVIRONMENT }}
        run: |
          aws lambda update-function-code \
            --function-name $LAMBDA_FUNCTION_NAME \
            --image-uri $ECR_REGISTRY/$LAMBDA_ECR_REPOSITORY:$IMAGE_TAG
          aws lambda wait function-updated \
            --function-name $LAMBDA_FUNCTION_NAME

          OPENAI_KEY=$(aws ssm get-parameter --name "$SSM_PREFIX/openai-api-key" --with-decryption --query 'Parameter.Value' --output text)
          CURRENT_ENV=$(aws lambda get-function-configuration \
            --function-name $LAMBDA_FUNCTION_NAME \
            --query 'Environment.Variables' --output json)
          UPDATED_ENV=$(echo "$CURRENT_ENV" | jq --arg KEY "$OPENAI_KEY" '. + {"OPENAI_API_KEY": $KEY}')
          aws lambda update-function-configuration \
            --function-name $LAMBDA_FUNCTION_NAME \
            --environment "{\"Variables\": $UPDATED_ENV}" > /dev/null
          aws lambda wait function-updated \
            --function-name $LAMBDA_FUNCTION_NAME

  # ============================================================================
  # Migrate DB: ECSマイグレーションタスク実行
  # ============================================================================
  migrate-db:
    needs: build-app
    runs-on: ubuntu-latest
    if: github.ref == 'refs/heads/develop' || github.ref == 'refs/heads/main'
    env:
      ECS_CLUSTER: ${{ github.ref == 'refs/heads/main' && 'metalk-production' || 'metalk-staging' }}
    steps:
      - uses: aws-actions/configure-aws-credentials@v4
        with:
          role-to-assume: ${{ secrets.AWS_ROLE_ARN }}
          aws-region: ${{ env.AWS_REGION }}

      - name: Run database migration
        env:
          MIGRATION_TASK_DEF: ${{ vars.MIGRATION_TASK_DEFINITION }}
          SUBNET_IDS: ${{ vars.SUBNET_IDS }}
          SECURITY_GROUP_IDS: ${{ vars.SECURITY_GROUP_IDS }}
        run: |
          TASK_ARN=$(aws ecs run-task \
            --cluster $ECS_CLUSTER \
            --task-definition $MIGRATION_TASK_DEF \
            --launch-type FARGATE \
            --network-configuration "awsvpcConfiguration={subnets=[$SUBNET_IDS],securityGroups=[$SECURITY_GROUP_IDS],assignPublicIp=ENABLED}" \
            --overrides '{"containerOverrides":[{"name":"migration","command":["npx","prisma","migrate","deploy"]}]}' \
            --query 'tasks[0].taskArn' --output text)
          echo "Waiting for migration task: $TASK_ARN"
          aws ecs wait tasks-stopped --cluster $ECS_CLUSTER --tasks $TASK_ARN
          EXIT_CODE=$(aws ecs describe-tasks --cluster $ECS_CLUSTER --tasks $TASK_ARN --query 'tasks[0].containers[0].exitCode' --output text)
          if [ "$EXIT_CODE" != "0" ]; then
            echo "Migration failed with exit code $EXIT_CODE"
            exit 1
          fi

  # ============================================================================
  # Deploy ECS: タスク定義更新 + ECSサービス更新
  # ============================================================================
  deploy-ecs:
    needs: [build-app, migrate-db]
    runs-on: ubuntu-latest
    if: github.ref == 'refs/heads/develop' || github.ref == 'refs/heads/main'
    env:
      ENVIRONMENT: ${{ github.ref == 'refs/heads/main' && 'production' || 'staging' }}
      ECS_CLUSTER: ${{ github.ref == 'refs/heads/main' && 'metalk-production' || 'metalk-staging' }}
    steps:
      - uses: aws-actions/configure-aws-credentials@v4
        with:
          role-to-assume: ${{ secrets.AWS_ROLE_ARN }}
          aws-region: ${{ env.AWS_REGION }}

      - uses: aws-actions/amazon-ecr-login@v2
        id: ecr

      - name: Update task definition image
        id: task-def
        env:
          ECR_REGISTRY: ${{ steps.ecr.outputs.registry }}
          ECR_REPOSITORY: ${{ vars.ECR_REPOSITORY }}
          IMAGE_TAG: ${{ github.sha }}
          ECS_SERVICE: ${{ vars.ECS_SERVICE }}
          SSM_PREFIX: /metalk/${{ env.ENVIRONMENT }}
        run: |
          if [ -z "$SSM_PREFIX" ]; then
            echo "Error: SSM_PREFIX is not set"
            exit 1
          fi
          TASK_DEF_ARN=$(aws ecs describe-services \
            --cluster $ECS_CLUSTER \
            --services $ECS_SERVICE \
            --query 'services[0].taskDefinition' --output text)
          TASK_DEF=$(aws ecs describe-task-definition \
            --task-definition $TASK_DEF_ARN \
            --query 'taskDefinition' --output json)
          REQUIRED_SECRETS='[
            {"name":"DATABASE_URL","valueFrom":"'"$SSM_PREFIX"'/database-url"},
            {"name":"NEXTAUTH_SECRET","valueFrom":"'"$SSM_PREFIX"'/nextauth-secret"},
            {"name":"NEXTAUTH_URL","valueFrom":"'"$SSM_PREFIX"'/nextauth-url"},
            {"name":"STORAGE_PROVIDER","valueFrom":"'"$SSM_PREFIX"'/storage-provider"},
            {"name":"MINIO_ACCESS_KEY","valueFrom":"'"$SSM_PREFIX"'/minio-access-key"},
            {"name":"MINIO_SECRET_KEY","valueFrom":"'"$SSM_PREFIX"'/minio-secret-key"},
            {"name":"MINIO_BUCKET_NAME","valueFrom":"'"$SSM_PREFIX"'/minio-bucket-name"},
            {"name":"AWS_REGION","valueFrom":"'"$SSM_PREFIX"'/aws-region"},
            {"name":"OPENAI_API_KEY","valueFrom":"'"$SSM_PREFIX"'/openai-api-key"},
            {"name":"STRIPE_SECRET_KEY","valueFrom":"'"$SSM_PREFIX"'/stripe-secret-key"},
            {"name":"DOCUMENT_ANALYSIS_LAMBDA_ARN","valueFrom":"'"$SSM_PREFIX"'/document-analysis-lambda-arn"},
            {"name":"ANALYSIS_CALLBACK_SECRET","valueFrom":"'"$SSM_PREFIX"'/analysis-callback-secret"}
          ]'
          NEW_TASK_DEF=$(echo "$TASK_DEF" | jq \
            --arg IMAGE "$ECR_REGISTRY/$ECR_REPOSITORY:$IMAGE_TAG" \
            --argjson SECRETS "$REQUIRED_SECRETS" \
            '.containerDefinitions[0].image = $IMAGE |
             .containerDefinitions[0].secrets = $SECRETS |
             del(.taskDefinitionArn, .revision, .status, .requiresAttributes, .compatibilities, .registeredAt, .registeredBy)')
          NEW_ARN=$(aws ecs register-task-definition \
            --cli-input-json "$NEW_TASK_DEF" \
            --query 'taskDefinition.taskDefinitionArn' --output text)
          echo "task_def_arn=$NEW_ARN" >> "$GITHUB_OUTPUT"

      - name: Deploy to ECS
        env:
          ECS_SERVICE: ${{ vars.ECS_SERVICE }}
        run: |
          aws ecs update-service \
            --cluster $ECS_CLUSTER \
            --service $ECS_SERVICE \
            --task-definition ${{ steps.task-def.outputs.task_def_arn }} \
            --query 'service.serviceName' --output text
          echo "Waiting for service to stabilize..."
          aws ecs wait services-stable \
            --cluster $ECS_CLUSTER \
            --services $ECS_SERVICE
